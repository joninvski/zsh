#!/bin/zsh

export GIT_AUTHOR_NAME="${FULLNAME}"
export GIT_AUTHOR_EMAIL="${EMAIL}"
export GIT_COMMITTER_NAME="${FULLNAME}"
export GIT_COMMITTER_EMAIL="${EMAIL}"


# ----------------------------------------------------------------------
# The following implements a caching mechanism for git information.
# The RPROMPT executes get_git_bprompt_info() and include the output...
#
#   setopt prompt_subst
#   RPROMPT="$(get_git_prompt_info)"
#
# ATM we only capture the git 
export __CURRENT_GIT_BRANCH=
export __CURRENT_GIT_VARS_INVALID=1

zsh_git_invalidate_vars() {
    export __CURRENT_GIT_VARS_INVALID=1
}

zsh_git_compute_vars() {
    export __CURRENT_GIT_BRANCH="$(parse_git_branch)"
    export __CURRENT_GIT_VARS_INVALID=
}

# get the name of the branch we are on
parse_git_branch() {
    git-branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1) -- /'
}

# on each chdir update the cached git variable(s)
preexec_functions+='zsh_preexec_update_git_vars'
#precmd_functions+='zsh_precmd_update_git_vars'
chpwd_functions+='zsh_chpwd_update_git_vars'
zsh_preexec_update_git_vars() {
    case "$(history $HISTCMD)" in 
        *git*) zsh_git_invalidate_vars
        ;;
    esac
}
zsh_chpwd_update_git_vars() {
    export __CURRENT_GIT_BRANCH="$(parse_git_branch)"
}

# this function returns the current git branch
get_git_prompt_info() {
    test -n "$__CURRENT_GIT_VARS_INVALID" && zsh_git_compute_vars
    if [ "$__CURRENT_GIT_BRANCH" ]; then
         status_icon=$(git_status)
         echo "$status_icon%{$fg[yellow]%} $__CURRENT_GIT_BRANCH"
    fi
}

#Show character if index and/or work-tree are dirty
git_status() {
    my_status=$(git status)

    if [[ "$my_status" == *"Changes to be committed"* ]]; then
        output="%{$fg[green]%}+"
    fi

    if [[ "$my_status" == *"Changed but not updated"* ]]; then
        output="$output%{$fg[red]%}*"
    fi

    echo $output
}
